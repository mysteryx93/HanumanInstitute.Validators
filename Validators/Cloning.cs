using System;
using System.IO;
using System.Text.Json;
using System.Text.Json.Serialization.Metadata;

namespace HanumanInstitute.Validators;

/// <summary>
/// Provides utility methods to clone objects.
/// </summary>
public static class Cloning
{
    /// <summary>
    /// Copies all fields from one instance of a class to another.
    /// </summary>
    /// <typeparam name="T">The type of class to copy.</typeparam>
    /// <param name="source">The class to copy.</param>
    /// <param name="target">The class to copy to.</param>
    public static void CopyAllFields<T>(T source, T target)
    {
        var type = typeof(T);
        foreach (var sourceProperty in type.GetProperties())
        {
            var targetProperty = type.GetProperty(sourceProperty.Name);
            if (targetProperty?.SetMethod != null)
            {
                targetProperty.SetValue(target, sourceProperty.GetValue(source, null), null);
            }
        }
        foreach (var sourceField in type.GetFields())
        {
            var targetField = type.GetField(sourceField.Name);
            targetField?.SetValue(target, sourceField.GetValue(source));
        }
    }

    /// <summary>
    /// Performs a shallow clone of specified object by copying all properties and fields, non-recursively.
    /// </summary>
    /// <param name="source">The object to clone.</param>
    /// <typeparam name="T">The type of object to clone.</typeparam>
    /// <returns>The cloned object.</returns>
    [Obsolete("This method relies on reflection. For better performance, use DeepClone with Json Source Generator. If you specifically need shallow copy, use CopyAllFields, or MemberwiseClone within the class to clone.")]
    public static T ShallowClone<T>(T source)
        where T : new()
    {
        if (source == null) { return default!; }

        var result = new T();
        CopyAllFields(source, result);
        return result;
    }
    
    /// <summary>
    /// Performs a deep clone of specified object by serializing and deserializing it.
    /// </summary>
    /// <param name="source">The object to clone.</param>
    /// <param name="serializerContext">Optional, a serializer context generated by Json Source Generator.</param>
    /// <typeparam name="T">The type of object to clone.</typeparam>
    /// <returns>The cloned object.</returns>
    public static T DeepClone<T>(T source, IJsonTypeInfoResolver? serializerContext)
    {
        if (source == null) { return default!; }

        using var stream = new MemoryStream();
        var options = new JsonSerializerOptions()
        {
            IgnoreReadOnlyProperties = true,
            IgnoreReadOnlyFields = true,
            WriteIndented = false,
            TypeInfoResolver = serializerContext
        };
        JsonSerializer.Serialize(stream, source, options);
        stream.Seek(0, SeekOrigin.Begin);
        var result = (T)JsonSerializer.Deserialize(stream, typeof(T), options)!;
        return result;
    }
}
